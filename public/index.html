<!doctype html><html lang="zh-CN"> <head> <meta charset="utf-8" /> <title>ä¸ƒå¤•èŠå¤©</title> <meta name="description" content="åŸºäº Cloudflare Workers çš„å®æ—¶èŠå¤©åº”ç”¨" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <link rel="stylesheet" href="css/normalize.css" /> <link rel="stylesheet" href="css/skeleton.css" /> <link rel="stylesheet" href="styles.css" /> <script src="/dist/index.js" type="module"></script> </head> <body> <div class="app-container"> <!-- å·¦ä¾§ç”¨æˆ·ä¿¡æ¯é¢æ¿ --> <div class="user-panel"> <div class="user-info"> <h4>ä¸ƒå¤•èŠå¤©</h4> <div class="avatar-section"> <div class="avatar-preview" id="avatarPreview">ğŸ‘¤</div> <select id="avatarSelect" class="avatar-select"> <option value="ğŸ‘¤">é»˜è®¤å¤´åƒ</option> <option value="ğŸ˜Š">å¾®ç¬‘</option> <option value="ğŸ˜">é…·</option> <option value="ğŸ¤©">æ˜Ÿæ˜Ÿçœ¼</option> <option value="ğŸ¥°">çˆ±å¿ƒ</option> <option value="ğŸ˜‡">å¤©ä½¿</option> </select> </div> <div class="input-group"> <label for="userName">æ˜µç§°</label> <input type="text" id="userName" placeholder="è¯·è¾“å…¥æ˜µç§°" class="u-full-width" /> </div> <div class="info-group"> <label>ç”¨æˆ· ID</label> <div class="info-value" id="userId">-</div> </div> <div class="info-group"> <label>èŠå¤©å®¤ ID</label> <div class="info-value" id="roomId">-</div> </div> <button id="saveUserInfo" class="button-primary u-full-width">ä¿å­˜ä¿¡æ¯</button> </div> </div>
text
  <!-- å³ä¾§èŠå¤©åŒºåŸŸ -->
  <div class="chat-panel">
    <div id="root"></div>
  </div>
</div>
</body> </html>
================================================
FILE: public/styles.css
================================================
/* å…¨å±€æ ·å¼ */

{
box-sizing: border-box;
}

body, html {
height: 100%;
margin: 0;
padding: 0;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.app-container {
display: flex;
height: 100vh;
overflow: hidden;
}

/* å·¦ä¾§ç”¨æˆ·é¢æ¿ */
.user-panel {
width: 300px;
background-color: #b3cc9c;
padding: 30px 20px;
display: flex;
flex-direction: column;
border-right: 2px solid #95b37a;
}

.user-info h4 {
color: #2d5016;
text-align: center;
margin-bottom: 30px;
font-weight: 600;
}

.avatar-section {
margin-bottom: 20px;
text-align: center;
}

.avatar-preview {
width: 80px;
height: 80px;
border-radius: 50%;
background: white;
display: flex;
align-items: center;
justify-content: center;
font-size: 40px;
margin: 0 auto 15px;
border: 3px solid #95b37a;
}

.avatar-select {
width: 100%;
padding: 8px;
border: 1px solid #95b37a;
border-radius: 4px;
background: white;
}

.input-group, .info-group {
margin-bottom: 20px;
}

.input-group label, .info-group label {
display: block;
margin-bottom: 5px;
color: #2d5016;
font-weight: 500;
}

.input-group input {
width: 100%;
padding: 10px;
border: 1px solid #95b37a;
border-radius: 4px;
background: white;
}

.info-group .info-value {
padding: 10px;
background: white;
border: 1px solid #95b37a;
border-radius: 4px;
color: #666;
font-size: 14px;
word-break: break-all;
}

#saveUserInfo {
background-color: #7aa35c;
border-color: #7aa35c;
color: white;
padding: 12px;
font-weight: 500;
}

#saveUserInfo:hover {
background-color: #698b4f;
border-color: #698b4f;
}

/* å³ä¾§èŠå¤©é¢æ¿ */
.chat-panel {
flex: 1;
background-color: white;
display: flex;
flex-direction: column;
}

#root {
flex: 1;
display: flex;
flex-direction: column;
height: 100%;
}

/* èŠå¤©æ¶ˆæ¯åŒºåŸŸ */
.chat-container {
flex: 1;
display: flex;
flex-direction: column;
height: 100%;
padding: 20px;
}

.messages-container {
flex: 1;
overflow-y: auto;
padding: 20px 0;
margin-bottom: 20px;
}

.message {
display: flex;
align-items: flex-start;
margin-bottom: 15px;
max-width: 70%;
}

.message.own {
align-self: flex-end;
flex-direction: row-reverse;
margin-left: auto;
}

.message.other {
align-self: flex-start;
}

.message-avatar {
width: 40px;
height: 40px;
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
font-size: 18px;
flex-shrink: 0;
margin: 0 10px;
}

.message.own .message-avatar {
background-color: #a4f678;
}

.message.other .message-avatar {
background-color: #f0f0f0;
}

.message-content {
padding: 12px 16px;
border-radius: 18px;
position: relative;
word-wrap: break-word;
}

.message.own .message-content {
background-color: #a4f678;
border-bottom-right-radius: 4px;
}

.message.other .message-content {
background-color: white;
border: 1px solid #e0e0e0;
border-bottom-left-radius: 4px;
}

.message-user {
font-weight: 600;
font-size: 12px;
margin-bottom: 4px;
color: #666;
}

.message-text {
margin: 0;
line-height: 1.4;
}

/* æ¶ˆæ¯è¾“å…¥åŒºåŸŸ */
.message-input-container {
display: flex;
gap: 10px;
padding: 20px;
background: #f8f9fa;
border-top: 1px solid #e0e0e0;
}

.message-input {
flex: 1;
padding: 12px 16px;
border: 2px solid #e0e0e0;
border-radius: 25px;
outline: none;
font-size: 14px;
transition: border-color 0.2s;
}

.message-input:focus {
border-color: #b3cc9c;
}

.send-button {
padding: 12px 24px;
background-color: #b3cc9c;
color: white;
border: none;
border-radius: 25px;
cursor: pointer;
font-weight: 500;
transition: background-color 0.2s;
min-width: 80px;
}

.send-button:hover {
background-color: #9bb583;
}

.send-button:disabled {
background-color: #cccccc;
cursor: not-allowed;
}

/* æ»šåŠ¨æ¡æ ·å¼ */
.messages-container::-webkit-scrollbar {
width: 6px;
}

.messages-container::-webkit-scrollbar-track {
background: #f1f1f1;
}

.messages-container::-webkit-scrollbar-thumb {
background: #c1c1c1;
border-radius: 3px;
}

.messages-container::-webkit-scrollbar-thumb:hover {
background: #a8a8a8;
}

================================================
FILE: src/client/index.tsx
================================================
import { createRoot } from "react-dom/client";
import { usePartySocket } from "partysocket/react";
import React, { useState, useEffect, useRef } from "react";
import {
BrowserRouter,
Routes,
Route,
Navigate,
useParams,
} from "react-router";
import { nanoid } from "nanoid";

import { names, type ChatMessage, type Message } from "../shared";

// ç”¨æˆ·ä¿¡æ¯æ¥å£
interface UserInfo {
userId: string;
userName: string;
userAvatar: string;
}

function App() {
const { room } = useParams();
const [userInfo, setUserInfo] = useState<UserInfo | null>(null);
const [messages, setMessages] = useState<ChatMessage[]>([]);
const [inputMessage, setInputMessage] = useState("");
const messagesEndRef = useRef<HTMLDivElement>(null);

// ä» localStorage åŠ è½½ç”¨æˆ·ä¿¡æ¯
useEffect(() => {
const savedUserInfo = localStorage.getItem('qixiUserInfo');
if (savedUserInfo) {
setUserInfo(JSON.parse(savedUserInfo));
} else {
// åˆ›å»ºæ–°ç”¨æˆ·
const newUserInfo: UserInfo = {
userId: nanoid(8),
userName: names[Math.floor(Math.random() * names.length)],
userAvatar: "ğŸ‘¤"
};
setUserInfo(newUserInfo);
localStorage.setItem('qixiUserInfo', JSON.stringify(newUserInfo));
}
}, []);

// æ›´æ–°é¡µé¢ä¸Šçš„ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤º
useEffect(() => {
if (userInfo) {
const userIdElement = document.getElementById('userId');
const roomIdElement = document.getElementById('roomId');
const userNameInput = document.getElementById('userName') as HTMLInputElement;
const avatarSelect = document.getElementById('avatarSelect') as HTMLSelectElement;
const avatarPreview = document.getElementById('avatarPreview');

text
  if (userIdElement) userIdElement.textContent = userInfo.userId;
  if (roomIdElement) roomIdElement.textContent = room || '';
  if (userNameInput) userNameInput.value = userInfo.userName;
  if (avatarSelect) avatarSelect.value = userInfo.userAvatar;
  if (avatarPreview) avatarPreview.textContent = userInfo.userAvatar;
}
}, [userInfo, room]);

// è®¾ç½®ç”¨æˆ·ä¿¡æ¯ä¿å­˜åŠŸèƒ½
useEffect(() => {
const saveButton = document.getElementById('saveUserInfo');
const userNameInput = document.getElementById('userName') as HTMLInputElement;
const avatarSelect = document.getElementById('avatarSelect') as HTMLSelectElement;
const avatarPreview = document.getElementById('avatarPreview');

text
const handleSave = () => {
  if (userInfo && userNameInput && avatarSelect) {
    const updatedUserInfo: UserInfo = {
      ...userInfo,
      userName: userNameInput.value || userInfo.userName,
      userAvatar: avatarSelect.value
    };
    setUserInfo(updatedUserInfo);
    localStorage.setItem('qixiUserInfo', JSON.stringify(updatedUserInfo));
    
    if (avatarPreview) {
      avatarPreview.textContent = avatarSelect.value;
    }
    
    alert('ç”¨æˆ·ä¿¡æ¯å·²ä¿å­˜ï¼');
  }
};

const handleAvatarChange = () => {
  if (avatarPreview && avatarSelect) {
    avatarPreview.textContent = avatarSelect.value;
  }
};

if (saveButton) saveButton.addEventListener('click', handleSave);
if (avatarSelect) avatarSelect.addEventListener('change', handleAvatarChange);

return () => {
  if (saveButton) saveButton.removeEventListener('click', handleSave);
  if (avatarSelect) avatarSelect.removeEventListener('change', handleAvatarChange);
};
}, [userInfo]);

// è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
useEffect(() => {
messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
}, [messages]);

const socket = usePartySocket({
party: "chat",
room,
onMessage: (evt) => {
const message = JSON.parse(evt.data as string) as Message;
if (message.type === "add") {
const foundIndex = messages.findIndex((m) => m.id === message.id);
if (foundIndex === -1) {
setMessages((messages) => [
...messages,
{
id: message.id,
content: message.content,
user: message.user,
role: message.role,
},
]);
} else {
setMessages((messages) => {
return messages
.slice(0, foundIndex)
.concat({
id: message.id,
content: message.content,
user: message.user,
role: message.role,
})
.concat(messages.slice(foundIndex + 1));
});
}
} else if (message.type === "update") {
setMessages((messages) =>
messages.map((m) =>
m.id === message.id
? {
id: message.id,
content: message.content,
user: message.user,
role: message.role,
}
: m,
),
);
} else {
setMessages(message.messages);
}
},
});

const handleSendMessage = (e: React.FormEvent) => {
e.preventDefault();
if (!inputMessage.trim() || !userInfo) return;

text
const chatMessage: ChatMessage = {
  id: nanoid(8),
  content: inputMessage.trim(),
  user: userInfo.userName,
  role: "user",
};

setMessages((messages) => [...messages, chatMessage]);
socket.send(
  JSON.stringify({
    type: "add",
    ...chatMessage,
  } satisfies Message),
);

setInputMessage("");
};

if (!userInfo) {
return <div>åŠ è½½ä¸­...</div>;
}

return (
<div className="chat-container">
<div className="messages-container">
{messages.map((message) => {
const isOwnMessage = message.user === userInfo.userName;
return (
<div
key={message.id}
className={message ${isOwnMessage ? 'own' : 'other'}}
>
<div className="message-avatar">
{isOwnMessage ? userInfo.userAvatar : 'ğŸ‘¤'}
</div>
<div className="message-content">
<div className="message-user">{message.user}</div>
<div className="message-text">{message.content}</div>
</div>
</div>
);
})}
<div ref={messagesEndRef} />
</div>

text
  <form onSubmit={handleSendMessage} className="message-input-container">
    <input
      type="text"
      value={inputMessage}
      onChange={(e) => setInputMessage(e.target.value)}
      placeholder="è¾“å…¥æ¶ˆæ¯..."
      className="message-input"
      autoComplete="off"
    />
    <button
      type="submit"
      disabled={!inputMessage.trim()}
      className="send-button"
    >
      å‘é€
    </button>
  </form>
</div>
);
}

createRoot(document.getElementById("root")!).render(
<BrowserRouter>
<Routes>
<Route path="/" element={<Navigate to={/${nanoid()}} />} />
<Route path="/:room" element={<App />} />
<Route path="*" element={<Navigate to="/" />} />
</Routes>
</BrowserRouter>,
);

================================================
FILE: src/server/index.ts
================================================
import {
type Connection,
Server,
type WSMessage,
routePartykitRequest,
} from "partyserver";

import type { ChatMessage, Message } from "../shared";

export class Chat extends Server<Env> {
static options = { hibernate: true };

messages = [] as ChatMessage[];

broadcastMessage(message: Message, exclude?: string[]) {
this.broadcast(JSON.stringify(message), exclude);
}

onStart() {
// åˆ›å»ºæ¶ˆæ¯è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
this.ctx.storage.sql.exec(
CREATE TABLE IF NOT EXISTS messages (id TEXT PRIMARY KEY, user TEXT, role TEXT, content TEXT),
);

text
// ä»æ•°æ®åº“åŠ è½½æ¶ˆæ¯
this.messages = this.ctx.storage.sql
  .exec(`SELECT * FROM messages`)
  .toArray() as ChatMessage[];
}

onConnect(connection: Connection) {
connection.send(
JSON.stringify({
type: "all",
messages: this.messages,
} satisfies Message),
);
}

saveMessage(message: ChatMessage) {
// æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å·²å­˜åœ¨
const existingMessage = this.messages.find((m) => m.id === message.id);
if (existingMessage) {
this.messages = this.messages.map((m) => {
if (m.id === message.id) {
return message;
}
return m;
});
} else {
this.messages.push(message);
}

text
// ä¿å­˜åˆ°æ•°æ®åº“
this.ctx.storage.sql.exec(
  `INSERT INTO messages (id, user, role, content) VALUES ('${
    message.id
  }', '${message.user}', '${message.role}', ${JSON.stringify(
    message.content,
  )}) ON CONFLICT (id) DO UPDATE SET content = ${JSON.stringify(
    message.content,
  )}`,
);
}

onMessage(connection: Connection, message: WSMessage) {
// å¹¿æ’­æ¶ˆæ¯ç»™å…¶ä»–ç”¨æˆ·
this.broadcast(message);

text
// æ›´æ–°æœ¬åœ°æ¶ˆæ¯å­˜å‚¨
const parsed = JSON.parse(message as string) as Message;
if (parsed.type === "add" || parsed.type === "update") {
  this.saveMessage(parsed);
}
}
}

export default {
async fetch(request, env) {
return (
(await routePartykitRequest(request, { ...env })) ||
env.ASSETS.fetch(request)
);
},
} satisfies ExportedHandler<Env>;

================================================
FILE: package.json
================================================
{
"name": "qixichat",
"description": "åŸºäº Durable Objects å’Œ PartyKit æ„å»ºçš„å®æ—¶èŠå¤©åº”ç”¨",
"private": true,
"cloudflare": {
"label": "ä¸ƒå¤•èŠå¤©åº”ç”¨",
"products": [
"Workers",
"Durable Objects"
],
"categories": [],
"icon_urls": [
"https://imagedelivery.net/wSMYJvS3Xw-n339CbDyDIA/5ca0ca32-e897-4699-d4c1-6b680512f000/public"
],
"preview_image_url": "https://imagedelivery.net/wSMYJvS3Xw-n339CbDyDIA/e18406a7-a5d8-4c3d-2b9e-f59e6beb9200/public",
"publish": true
},
"dependencies": {
"nanoid": "5.1.5",
"partyserver": "0.0.66",
"partysocket": "1.1.3",
"react": "^18.0.0",
"react-dom": "^18.0.0",
"react-router": "7.6.3"
},
"devDependencies": {
"@types/react": "^18.0.0",
"@types/react-dom": "^18.0.0",
"esbuild": "0.25.2",
"typescript": "5.8.3",
"wrangler": "4.21.x"
},
"scripts": {
"cf-typegen": "wrangler types ./src/server/worker-configuration.d.ts",
"check": "tsc --project src/client && tsc --project src/server && wrangler deploy --dry-run",
"deploy": "wrangler deploy",
"dev": "wrangler dev"
}
}
